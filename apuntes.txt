GENERALES
 - para que nginx pueda acceder a los archivos html que genera php-fpm, necesitamos un volumen para guardar esos archivos y que el contenedor de nginx los pueda ver. Sin ese volumen, los archivos php solo existen en el contenedor de wordpress-php-fpm. Uno de los problemas que tuve cuando ya estaban los 3 contenedores hechos y activos era que veia la pagina de welcome de nginx en vez de la de wordpress y era precisamente porque el contenedor de nginx no podia ver el index.php que tenia el contenedor de wp/php y se iba a la ruta predeterminada (/var/www/html/) y encontraba el .html de nginx y me lo mostraba. Por eso necesitamos el volumen para este proyecto.

	A Docker volume (or a bind mount) lets you share a directory between containers. You put WordPress files in a volume and mount it in both containers:
	In the WordPress container: PHP-FPM reads and executes the files.
	In the NGINX container: NGINX sees the same files and serves them.


 - cuidado con hacer 'stop' y 'start' en los contenedores. sobretodo si hay otros activos que no se han reseteado. En los archivos de configuracion de wordpress tuve problemas porque reutilizaba la misma imagen y hacia start y stop creo y no tenia bien controlado que pasa cuando el config php ya esta creado o cuando los usuarios de acceso a wp ya estan creados, etc. Maybe este problema se resuelve solo si usas docker compose. esto me ha pasado usando los comandos manuales de docker.

 - la gracia de los archivos .env es tener todas las variables en un mismo sitio(que no sea a la vista en el Dockerfile). A no ser que uses docker Compose, si montas los contenedores de manera manual con docker run, no tiene sentido tener archivos .env porque copiar el .env en el contenedor no a√±ade automaticamente esas variables en el environment verdadero del contenedor. Tendriamos que hacer un export de cada variable. Y parsear el archivo para hacer un export manualmente me parece un rollo. Asi que para testear manualmente con solo docker, hay que a√±adir la flag -e NOMBRE_DE_VAR=valor y asi se inicia el contenedor con esas variables de entorno.

  as√≠ lo hice para mariadb y wordpress:
    docker run -d --name mariadb --network inception_net -e MYSQL_ROOT_PASSWORD=supersecretroot -e MYSQL_DATABASE=wordpress -e MYSQL_USER=db_user -e MYSQL_PASSWORD=db_pass mariadb_image:latest 

    docker run -d --name wordpress --network inception_net -e DATABASE_HOST=mariadb -e DATABASE_USER_NAME=db_user -e DATABASE_USER_PASSWORD=db_pass -e DATABASE_NAME=wordpress -e DOMAIN_NAME=martalop.42.fr -e WORDPRESS_TITLE="My WP Site" -e WORDPRESS_ADMIN_USER=admin_marta -e WORDPRESS_ADMIN_PASSWORD=strongpassword -e WORDPRESS_AUTHOR_USER=author_marta -e WORDPRESS_AUTHOR_EMAIL=author@example.com -e WORDPRESS_AUTHOR_PASSWORD=authorpassword -e WORDPRESS_ADMIN_EMAIL=admin@example.com wordpress:latest

- OJITO con los nombres de los contenedores. Again, si usas docker-compose maybe esto ya no es problema, pero al hacer los comandos manualmente, si pones un nombre de contenedor diferente al que has puesto como identificador de un contenedor en un archivo de configuracion, problema porque no te va a reconocer la IP del contenedor con ese nombre. Hablo de cuando estan conectados en una network de  docker por ejemplo, o de si en un archivo de conf tenia puesta la conexion con mariadb:3306 y el contenedor no se llama mariadb, sino mariadb_container, no va a funcionar.

- los archivos que generan la base de datos y wordpress, que ponen en las carpetas /varlib/mysql y /var/www/html en sus correspondientes contenedores, tambien aparecen en las carpetas /home/martalc/data/database y /home/martalc/data/wordpress en esta maquina virtual. Esa es la gracia de los volumenes. Que compartan una carpeta. Esto significa por ejemplo, que cuando wordpress genera el wp-confing.php, aunque luego hagamos docker compose down y lo eliminemos todo, seguimos teniendo ese archivo en nuestra mv. Y cuando volvemos a hacer docker compose up, los archivos que tenemos ahi tambien los heredan los contenedores en el momento de su creacion. Osea que cada vez que queremos borrar todo y empezar de 0, tenemos que borrar esos archivos de la maquina virtual, porque sino los contenedores los heredaran sin darnos cuenta. Como me ha dado cuenta yo?
Porque me estaba apareciendo la pagina de wordpress en el navegador, pero en vez de la de login, la de instalacion de wordpress. Esto pasaba porque aunque detectaba el wp-config.php (del previo docker compose up), no detectaba una base de datos por aguna razon. creo que para arreglarlo tengo aue cambiar la configuracion de wordpress para que compruebe todo esto.

- todo lo que hacemos una vez loggeados con cualquier usuario se queda permanentemente en los volumenes, aunque eliminemos los contenedores, a no ser que:
	> obv eliminiemos los volumenes con la flag -v al hacer docker compose down
	> eliminemos los archivos dentro de /home/martalc/data manualmente
	> cambiemos las variables del .env (como USER_NAME)
El .env file: ensures the new containers use the same DB name, username, and password ‚Üí WordPress connects to the same database inside that volume. Al conectarse a la misma base daa datos ya creada con anterioridad, podemos ver los posts antiguos.

- 'set -e' en los scripts makes the script exit immediately if any command fails

- todas las rutas dependenden de donde estemos al hacer 'docker run'. Si hagp ese comando desde inception/ no es lo mismo que si lo hago desde /inception/srcs/mariadb. Cuando hacemos 'docker build -t nombre_de_imagen ruta/de/directorio/del/contenedor' ese ultimo paramentro es muy importante y ya nos especifica donde vamos a crear la imagen y de donde va a buscar los archivos.

- cuando docker construye por primera vez una imagen y dentro del dockerfile con las instrucciones de esa imagen tenemos un entrypoint que ejecuta un script(archivo .sh), el script es copiado a la imagen, pero se ejecutara en el runtime, en el momento de ejecutar/iniciar el contenedor, osea cuando hagamos 'run' o 'docker compose up'.
Esto significa que cuando montamos todo + destruimos todo menos volumenes e imagenes y luego volvemos a montar todo, docker no tiene que volver a pasar por el dockerfile, pero SI que ejecuta el script, osea que TIENE que estar preparado para que funcione en todos los casos, tengamos ya los volumenes con info, o sea la primera vez que montamos los contenedores!!
En primer lugar, no tendria mucho sentido volver a crear los usuarios cuando ya estaban creados. Es verdad que todo esto se puede proteger un poco poniendo comandos con IF NOT EXIST o del estilo, pero mejor evitar volver a crear cuando ya tenemos la base de datos creada. En segundo lugar, he tenido muuchos problemas al checkear que mariadb este lista con el comando mariadb -u root loquesea. Porque si es la primera vez que creamos el contenedor, root aun no tiene seteada una password, pero si es la segunda vez que lo iniciamos y mantenemos los volumenes de la ultima vez,  root ya tiene root password, por tanto el comando fallara si no el especificamos la -p con la $MYSQL_ROOT_PASSWORD.
Esto es un poco lio y parece ser que el root que te crea automaticamente mariadb no 'necesita' la password porque tambien puede saber de manera segura quien es root con uno de sus UNIX sockets. Esto no lo acabo de tener claro pero bueno al final decido checkear siempre con password y hacer el checkeo solo cuando estoy segura de que, o ya he configurado la password, o estoy creando el contenedor con los datos anteriorres ya existentes en la base de datos.



CERTIFICADO OPENSSL Y $DOMAIN_NAME
- en la config de nginx, cuando creamos el certificado que necesitamos para hacer la conexion https, cuando aun probaba con la url https://localhost, tenia puesto:
	CN=martalop.42.fr
That means its Common Name (CN) only matches martalop.42.fr. So when your browser connected to https://localhost, it saw:

‚ÄúThe certificate is for a different host (martalop.42.fr).‚Äù

and it refused to complete the HTTPS handshake (unless you forced it). Browsers interpret that kind of TLS failure as a network error ‚Äî and when JS/CSS files fail to load due to a TLS mismatch, the console shows them as:
	"CORS request did not succeed. Status code: (null)"
este error lo vi en los console logs en el modo dev tools. Al cambiar el CN a localhost, ya cuadra.

El mayor problema que habia tenido por eso, era que estaba usando el DOMAIN_NAME=martalop.42.fr, en vez de localhost. Eso me causaba errores del mismo estilo de CORS. Esa variable la usaba en la inicializacion de la base de datos:
	wp core install --url=$DOMAIN_NAME ...
este comando le dice a mariadb que las url que use tenian que contener martalop.42.fr, como por ejemplo:
	https://martalop.42.fr/wp-includes/js/dist/...js
pero no podia acceder a esos sitios obviamente porque aun no tenia mi ip local como martalop.42.fr, por eso veia la primera pagina de inicio bien, excepto por algunos iconos que estaban mal puestos, desalineados y en otra font, no la correcta. Imagino porque no podia llegar a esos archivos javascript y me mostraba el texto como podia.


PHP-FPM (FastCGI Process Manager) 
Se encarga de generar los archivos php, ademas de gestionar las pools con los procesos de cada 'worker' y generar el html final que dara a el servidor, nginx. Es decir, cuando hay muchas php requests del servidor (nginx), cuando mucha gente se conecta a la web y pide un archivo html, nginx hace la traduccion a una request php (cuando no encuentra static files) que manda al php-fpm, que genera el php, pidiendo cosas a veces a la base de datos(mariadb), se encarga de gestionar esas peticiones y general el archivo html final que envia al servidor nginx a traves de otra fastCGI response. Nginx recibe el html y se lo envia al cliente(browser).

WORDPRESS
Al crear el archivo de configuracion de wp con 'wp config create', nos pide los datos de usuario, password, etc. Una de las cosas que nos pide es el '--dbhost'.
Esta es la direccion ip de la base de datos. Si usaramos un mismo container para wordpress y mariadb, pondriamos simplemente localhost. Pero como no es el caso, necesitamos identificar el contenedor de mariadb, para eso esta la docker network.
Con los dos contenerdores en la misma network simplemente podemos poner:
--dbhost=mariadb:3306. (3306 es el puerto en el que esta escuchando mariadb en ese contenedor y mariadb lo traduce docker a una ip valida tipo 172.18.0.2)
El error que vemos si intentamos configurar wordpress sin haber conectado la base de datos a la docker network es este:
	PHP Warning:  mysqli_real_connect(): php_network_getaddresses: getaddrinfo failed: Temporary failure in name resolution in phar:///usr/local/bin/wp/vendor/wp-cli/config-command/src/Config_Command.php on line 234
	Error: Database connection error (2002) php_network_getaddresses: getaddrinfo failed: Temporary failure in name resolution
Este error lo he visto al mirar los docker logs del contenedor, donde me aparecia esto:
"Downloading WordPress 6.8.3 (en_US)... md5 hash verified: d2c8b06fa3875fb890e3fa8fdbbc42fb Success: WordPress downloaded.  parameter Error: 'wp-config.php' not found. Either create one manually or use wp config create. Error: 'wp-config.php' not found. Either create one manually or use wp config create."
Este error sale porque no habia podido completar el comando wp config create porque no podia traducir 'mariadb:3306' a ninguna ip, no habia network.

MARIADB (errores)
1. Why your current Dockerfile fails

ENTRYPOINT ["mariadb"]

mariadb is the client, not the server.

That‚Äôs why when you run the container, there‚Äôs no server running ‚Üí the socket /run/mysqld/mysqld.sock doesn‚Äôt exist ‚Üí you get ERROR 2002 (HY000).

You need to start mysqld, the server, instead.


2.  Por que no lanzar el servidor de mariadb y el cliente de mariadb a la vez en el container:

In a container, you generally want only the server running, because:

- The container itself is meant to be the database service.
- Other programs (WordPress, Adminer, or docker exec ‚Ä¶ mariadb) will connect to it when needed.
- If you try to launch both server + client in one container, one of them has to stay in the foreground as PID 1 ‚Äî but only one process can be the container‚Äôs ‚Äúmain process‚Äù.

You could technically script it (like mysqld & mariadb -u root) but:

- It goes against Docker best practices (one main service per container).
- The client would just sit there waiting for input, serving no real purpose.
- It makes your container harder to manage.


3. Si solo tengo esto en el script: 
"mariadb -u root <<-EOSQL
  CREATE DATABASE IF NOT EXISTS ${MYSQL_DATABASE};
  CREATE USER IF NOT EXISTS '${MYSQL_USER}'@'%' IDENTIFIED BY '${MYSQL_PASSWORD}';
  GRANT ALL PRIVILEGES ON ${MYSQL_DATABASE}.* TO '${MYSQL_USER}'@'%';
  FLUSH PRIVILEGES;
EOSQL"
Tenemos problemas, porque en ningun momento estoy seteando la password para el root user. Desde dentro del contenedor de mariadb, me tiene que pedir una contrasenya si yo hago 'docker exec -it mariadb bash' y luego 'mariadb'. No deberia de entrar solo, que es lo que me pasaba. Tambien deberia pedirme una password cuando entro con el usuario creado $MYSQL_USER_NAME (db_user). El comando para entrar con un usurio es: 'mariadb/mysql -u user_name -p [password]'.

4. como solo podemos correr un solo proceso en el container, cuando queremos crear una tabla en mariadb, necesitamos un usuario que se conecte como cliente(mariadb) al servidor (mysqld) y eso ya es un proceso, osea que lo hqcemos de manera temporal antes de lanzar el proceso real (PID 1) del contenedor. POr eso tenemos cosas como : "mysqladmin -u root shutdown" en el .sh.

5. passwords
# esta copia de el .env con las contrasenas esta prohibido por subject
# ‚ÄúPasswords must not be present in your Dockerfiles.‚Äù
# ademas, aunque lo haga, si creo la imagen con: "docker build -t inception-db srcs/mariadb" desde la carpeta de inception, tampoco me va a dejar copiar el .env por razones de seguridad, porque le he especificado que el build localtion seria la carpeta 'mariadb' y en esa el .env no existe.
COPY ../../.env /root/.env

6. no estaba cambiando la configuracion de mariadb para que pueda conectarse con cualquier ip. Solo me podia conectar conmmigo misma (localhost). Esta configuracion esta en /etc/mysql/mariadb.conf.d/50-server.cnf. He cambiado la linea de:
bind-address = 127.0.0.1, a: bind-address = 0.0.0.0. Con esto el contendor de wordpress puede econtrarme.
este cambio lo he anadido al script asi:

echo "üõ†Ô∏è Configuring MariaDB bind-address..."
cat > /etc/mysql/mariadb.conf.d/99-bind.cnf <<EOF
[mysqld]
bind-address = 0.0.0.0
EOF
echo "‚úÖ bind-address set to 0.0.0.0"

7. cuidado al hacer el check de que los volumenes ya tengan cosas dentro:

"In MariaDB ‚â•10.5, the user.frm file no longer exists because the system tables have moved to the InnoDB data dictionary (not .frm files anymore)"

resulta que en nuevas versiones de mariadb, las tablas estaran en /var/lib/mysql/mysql.ibd por ejemplo, y no en /var/lib/mysql/mysql/user.frm.

En el script de mariadb yp tenia una comprobacion de si existia el archivo user.frm, y a partir de ahi decidia si tenia que volver a configurar maridb o no, porq si existia el archivo, significaba que ya habia un volumen con info previa. Al final la mejor manera de checkear si hay cosas en las carpetas ligadas a los volumenes es checkear si /var/lib/mysql/mysql existie y si tiene archivos dentro o no. Asi se ha quedado mi script: 

if [ ! -d "/var/lib/mysql/mysql" ] || [ -z "$(ls -A /var/lib/mysql/mysql 2>/dev/null)" ]; then
    echo "Initializing system tables (directory empty)"
    mariadb-install-db --user=mysql --ldata=/var/lib/mysql --skip-test-db
    DB_WAS_EMPTY=true
else
    DB_WAS_EMPTY=false
fi

8. parece que al anadir esto "RUN rm -rf /var/lib/mysql/*" en el dockerfile de mariadb he conseguido que me creara todo de 0 la primera vez que creamos contenedores y volumenes. Imagino que me estaba dando problemas porque en algun momento puede que no haya cerrado bien algun contenedor que se ha quedado ligado a un volumen, pero nidea, porque yo siempre limpio la carpeta de los volumenes en el host (/home/martalc/data/database y /home/martalc/data/wordpress)


